#!/usr/bin/env python

# This script will not work if called directly.
# From the command line, you should call sfincsScan instead.
#
#
# This script launches a number of runs with parameters listed in the file runspec.dat.
# Such a file contains first a number of comment lines, beginning with ! (or % or #). 
# The last line beginning with ! contains the names of the variables listed on the lines
# below it. Each data line corresponds to one sfincs run. The variables not listed
# are left unchanged in the input.namelist. 
#
# On the hydra system some variables for the job file can also be included.
#
# Here is an example of a runspec.dat file:
#
#! This is a very short and ridiculous runspec.dat example file
#!
#! rN_wish dPhiHatdpsiN
#      0.5          0.0
#      0.2          0.7
#      0.2          2.0
#
#
# 

import os, inspect

print "This is "+ inspect.getfile(inspect.currentframe())
print "Beginning a runspec.dat scan."

runspecFilename = "runspec.dat"

################## Read the runspec file ##################
def readRunspec(therunspecFilename):
    def numberatend(strng):
        thenumb=0
        if strng[-2]=="_":
            thenumb=int(strng[-1])
        return thenumb

    if not os.path.isfile(therunspecFilename):
        print "Error! The file "+therunspecFilename+" must be present in the directory from which you call sfincsScan."
        exit(1)
    # Load the runspec file:
    with open(therunspecFilename, 'r') as rsf:
        runspecLines = rsf.readlines()
    
    lind=0
    while runspecLines[lind][0]=="!" or runspecLines[lind][0]=="%" or runspecLines[lind][0]=="#":
        lind+=1
    runparamnames=runspecLines[lind-1][2:].split()
    noElems=len(runparamnames)
    datalines=runspecLines[lind:]
    runparams=[[0 for j in range(noElems)] for i in range(len(datalines))]
    for datalineind in range(len(datalines)):
        thesplittedstring=datalines[datalineind].split()
        for parind in range(noElems):
           thestring=thesplittedstring[parind]
           thestring=thestring.replace('d','e').replace('D','e')
           if ("." in thestring) or ("e" in thestring):
               runparams[datalineind][parind]=float(thestring)
           else:
               runparams[datalineind][parind]=int(thestring)
    
    rsf.close()

    runnumbersatend=[0 for j in range(noElems)]
    runvectorlength=[0 for j in range(noElems)]
    for parind in range(noElems):
        runnumbersatend[parind]=numberatend(runparamnames[parind])
        if runnumbersatend[parind]>0:
            runvectorlength[parind+1-runnumbersatend[parind]:parind]=[runnumbersatend[parind] for j in range(runnumbersatend[parind])]

    return runparamnames, runparams, runnumbersatend, runvectorlength

##############################################################################

runparamnames, runparams, runnumbersatend, runvectorlength=readRunspec(runspecFilename)

# Read in the job.sfincsScan file:
with open(jobFilename, 'r') as f:
    jobFile = f.readlines()


numRunsInScan=len(runparams)
for runNum in range(numRunsInScan):
   dirNum = runNum-1
   while True:
      dirNum+=1
      dirName=str(dirNum)
      if dirNum<10:
         dirName = "0" + dirName
      if not os.path.exists(dirName):
          break
   os.mkdir(dirName)
   os.chdir(dirName)

   jobName="Sfnx."+dirName
   print "Beginning to handle job "+str(runNum+1)+" of "+str(numRunsInScan)+": "+dirName

   # Copy the job.sfincsScan file:
   thisJobFile = list(jobFile)
   # This next function is defined separately for each system in sfincsScan
   nameJobFile(thisJobFile,jobName)
   if sfincsSystem=="hydra":
       for parind in range(len(runparamnames)):
           if runparamnames[parind]=="node":
               for line in thisJobFile:
                   if "# @ node =" in line:
                       thisJobFile[thisJobFile.index(line)]="# @ node = "+str(runparams[runNum][parind])+"\n"
           if runparamnames[parind]=="tasks_per_node":
               for line in thisJobFile:
                   if "# @ tasks_per_node =" in line:
                       thisJobFile[thisJobFile.index(line)]="# @ tasks_per_node = "+str(runparams[runNum][parind])+"\n"
           if runparamnames[parind]=="ConsumableCpus":
               for line in thisJobFile:
                   if "# @ resources = ConsumableCpus" in line:
                       thisJobFile[thisJobFile.index(line)]="# @ resources = ConsumableCpus("+str(runparams[runNum][parind])+")\n"
           if runparamnames[parind]=="wall_clock_limit":
               hours=runparams[runNum][parind]//60
               minutes=runparams[runNum][parind]%60
               if hours<10:
                  hour_str="0"+str(hours)
               if minutes<10:
                  minute_str="0"+str(minutes)
               for line in thisJobFile:
                   if "# @ wall_clock_limit =" in line:
                       thisJobFile[thisJobFile.index(line)]="# @ wall_clock_limit = "+hour_str+":"+minute_str+":00\n"

   f = open(jobFilename,"w")
   f.writelines(thisJobFile)
   f.close()

   # Now copy the input.namelist file:
   f = open(filename,"w")
   for line in inputFile:
       for parind in range(len(runparamnames)):
           if runnumbersatend[parind]==0:
               if namelistLineContains(line,runparamnames[parind]):
                   line = "  "+runparamnames[parind]+" = "+str(runparams[runNum][parind])+" ! Set by sfincsScan.\n"
           else:
               if namelistLineContains(line,runparamnames[parind][:-3]):
                   if runnumbersatend[parind]==1:
                       str_stack="  "+runparamnames[parind][:-3]+" = "+str(runparams[runNum][parind])
                   else:
                       str_stack=str_stack+"  "+str(runparams[runNum][parind])
                   if runnumbersatend[parind]==runvectorlength[parind]:
                       line = str_stack+" ! Set by sfincsScan.\n"
       f.write(line)
   f.close()

   # Submit the sfincs job:
   try:
        # We need to include .split(" ") to separate the command-line arguments into an array of strings.   
        # I'm not sure why python requires this. 
        submissionResult = 1#subprocess.call(submitCommand.split(" "))
   except:
        print "ERROR! Unable to submit run "+jobName+" for some reason."
        raise
   else:
        if submissionResult==0:
            print "No errors submitting job "+jobName
        else:
            print "Nonzero exit code returned when trying to submit job "+jobName

   os.chdir("..")
